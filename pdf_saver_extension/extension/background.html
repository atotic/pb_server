<html>
<head>
<script>

function getServerUrl() {
	var s = localStorage['pdfServer'] || "http://localhost:27000/";
	return s;
}

function notifyProblem(msg) {
	console.error(msg);
	var notification = webkitNotifications.createNotification(
	  'icon.png', 'PDF Upload Problem!',  msg);
//	notification.show();
}

// Globals holding tab loading status
window.tabErrors = {}; // tabId => error mappings
window.tabCompletion = {};

function startPdfConversion(json) {
	// open new tab
	// load the url
	// when document ready, do saveAsPdf
	// in callback, post data back to server
	function pdfDone(tab, pdfData) {
		console.log("pdfDone");
		chrome.tabs.remove(tab.id);
		var xhr = new XMLHttpRequest();
		var url = getServerUrl() + "pdf_done?id=" + json.id;
		xhr.open("POST", url, true);
		xhr.onload = function (ev) {
			if (xhr.status != 200) {
				notifyProblem("PDF Upload failed. " + xhr.status + "\n" + xhr.responseText);
			}
			else
				console.info("PDF uploaded") 
		};
		xhr.onerror = function(ev) {
			notifyProblem("PDF Upload failed. PDF Upload server might be down.");
		};
		xhr.send(pdfData);		
	}
	
	function pdfFail(tab, message) {
		console.log("pdfFail " + message);
		chrome.tabs.remove(tab.id);
		var xhr = new XMLHttpRequest();
		var url = getServerUrl() + "pdf_fail?id=" + json.id
		xhr.open("POST", url, true);
		xhr.onerror = function(ev) {
			notifyProblem("Double failure: pdfFail xhr failed. Message was " + message);
		};
		xhr.send(message);
	}
	
	function tabCreated(tab) {
		var tabId = tab.id + "";
		if (tabId in window.tabErrors) {
			var err = window.tabErrors[tabId];
			delete window.tabErrors[tabId];
			pdfFail(tab, err);
			return;
		}
		else if (!(tabId in window.tabCompletion)) {
			// loading still incomplete
			console.log("waiting for tab completion");
			setTimeout(function() { tabCreated(tab) }, 100);
			return;
		}
		else { // tab loaded, generate pdf
			delete window.tabCompletion[tabId];
			options = {
				tabId: tab.id,
				dpi: 300,
				margin: [0],
				pageWidth: 612,
				pageHeight: 792
			}
			if ('dpi' in json) options.dpi = json.dpi;
			if ('margin' in json) options.margin = json.margin;
			if ('pageWidth' in json) options.pageWidth = json.pageWidth;
			if ('pageHeight' in json) options.pageHeight = json.pageHeight;
			debugger;
			try {
				chrome.pageCapture.saveAsPDF( options, function(pdfData) {
					if ('lastError' in chrome.extension)
						pdfFail(tab, chrome.extension.lastError.message);
					else
						pdfDone(tab, pdfData);
				});
			}
			catch(ex) {
				console.error("exception on saveAsPDF");
				console.error(ex);
			}
		}
	}
	function createTab(windowId) {
		chrome.tabs.create({'windowId': windowId, 'url': json.html_file_url}, tabCreated);
	}
	// Must create new window if no windows are available
	try {
		chrome.windows.getCurrent(function(w) {
			if (!w)
				chrome.windows.create({ width: 800, height: 800}, function(w) { createTab(w.id)} );
			else
				createTab(w.id);
		});
	}
	catch (e)
	{
		console.log("getCurrent threw exception");
		chrome.windows.create({}, createTab());
	}
}

var debugMe =1;
function pollForWork() {
/*	if (debugMe != 0)
		return;
	debugMe = 1;*/
	var xhr = new XMLHttpRequest();
	var url = getServerUrl() + "poll_pdf_work";
	xhr.open("GET", url, true);
	xhr.onload = function(ev) {
		if (xhr.status == 200)
			startPdfConversion(JSON.parse(xhr.responseText));
		else if (xhr.status == 204)
			;
		else {
			notifyProblem("Error getting work " + xhr.status);
		}
	}
	xhr.onerror = function(ev) {
		notifyProblem("Error getting work " + xhr.status);
	}
	xhr.send();
}

setInterval(pollForWork, 1000);

chrome.browserAction.onClicked.addListener(function(tab) {
	startPdfConversion(tab);
});

// Get called by detect_failure.js
chrome.extension.onRequest.addListener( function(request, sender, sendResponse) {
	window.tabErrors[sender.tab.id + ""] =  request;
});

chrome.webNavigation.onErrorOccurred.addListener( function(details) {
	console.log("Received error for " + details.tabId + " " + details.error);
	window.tabErrors[details.tabId + ""] = details.error;
});
chrome.webNavigation.onCompleted.addListener( function(details) {
	window.tabCompletion[details.tabId + ""] = true;
});
</script>
</head>